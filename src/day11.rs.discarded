use std::{collections::HashMap, rc::Rc};

/// The test file for day11 should include both p1 and p2,
/// separated by an empty line!
pub fn day11(_lines: Vec<String>, test: bool) {
    let (nodes_p1, nodes_p2) = parse_nodes(_lines, test);
    let p1 = count_paths("you", &nodes_p1);

    let mut path_count: HashMap<String, u64> = HashMap::new();
    let all_targets = vec![
        vec!["svr"],
        vec!["yur", "hlx", "thu"],
        vec!["ljo", "uvc", "vzm", "mbe", "vqv"],
        vec!["lau", "cvo", "esm", "wwx"],
        vec!["wxj", "nhi", "ikn", "pzo"],
        vec!["you", "ltb", "wkd", "xty"],
        vec!["out"]
    ];
    all_targets.iter().flatten().for_each(|&s| { path_count.insert(s.to_string(), 0); () });
    *path_count.get_mut("svr").unwrap() = 1;

    println!("Counting you to out");

    let mut targets_iter = all_targets.iter();
    let mut prev_targets = targets_iter.next().unwrap().clone();
    for (cycle, new_targets) in targets_iter.enumerate() {
        for prev in prev_targets {
            println!("Counting from {} to {:?}", prev, new_targets);
            count_paths_p2(prev, &nodes_p2, &mut path_count, false, false, cycle == 4, cycle == 1, new_targets);

        }
        prev_targets = new_targets.clone();
    }

    for targets in all_targets.iter().skip(1) {

    }
    let p2 = 0;

    println!("Part 1: {}", p1);
    println!("Part 2: {}", p2);
}

fn count_paths_p2(
    id: &str,
    nodes: &HashMap<String, Vec<String>>,
    path_count: &mut HashMap<String, u64>,
    visited_dac: bool,
    visited_fft: bool,
    dac_required: bool,
    fft_required: bool,
    targets: &Vec<&str>
) {
    if targets.contains(&id) {
        if dac_required && !visited_dac || fft_required && !visited_fft {
            return;
        }
        *path_count.get_mut(id).unwrap() += 1;
        return;
    }
    let exits = nodes.get(id).unwrap_or_else(|| panic!("Could not find exit '{}'",id));
    exits
        .iter()
        .for_each(|exit_id| {
            let dac = visited_dac || id == "dac";
            let fft = visited_fft || id == "fft";
            count_paths_p2(exit_id, nodes, path_count, dac, fft, dac_required, fft_required, targets)
        });
}

fn count_paths(id: &str, nodes: &HashMap<String, Vec<String>>) -> u64 {
    if id == "out" {
        return 1;
    }
    let exits = nodes.get(id).unwrap();
    exits
        .iter()
        .map(|exit_id| count_paths(exit_id, nodes))
        .sum()
}

fn parse_nodes(
    lines: Vec<String>,
    test: bool,
) -> (HashMap<String, Vec<String>>, HashMap<String, Vec<String>>) {
    if !test {
        let mut hash_nodes = parse_node_section(&lines);
        hash_nodes.insert("out".to_string(), vec![]);
        return (hash_nodes.clone(), hash_nodes);
    } else {
        let mut split = lines.split(|l| l.is_empty());
        let p1 = split.next().unwrap();
        let p2 = split.next().unwrap();
        let hash_nodes_p1 = parse_node_section(&p1.to_vec());
        let hash_nodes_p2 = parse_node_section(&p2.to_vec());
        return (hash_nodes_p1, hash_nodes_p2);
    }
}

fn parse_node_section(lines: &Vec<String>) -> HashMap<String, Vec<String>> {
    let mut hash_nodes: HashMap<String, Vec<String>> = HashMap::new();
    lines.iter().for_each(|l| {
        let (id, strcon) = l.split_once(':').unwrap();
        let connections = &strcon[1..]
            .split(" ")
            .map(|s| s.to_string())
            .collect::<Vec<String>>();
        hash_nodes.insert(id.to_string(), connections.clone());
    });
    hash_nodes
}
